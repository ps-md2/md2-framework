package de.wwu.md2.framework.generator.ios

import de.wwu.md2.framework.generator.util.DataContainer
import de.wwu.md2.framework.mD2.AbstractViewGUIElementRef
import de.wwu.md2.framework.mD2.Boolean
import de.wwu.md2.framework.mD2.BooleanExpression
import de.wwu.md2.framework.mD2.Condition
import de.wwu.md2.framework.mD2.EqualsExpression
import de.wwu.md2.framework.mD2.FloatVal
import de.wwu.md2.framework.mD2.GuiElementStateExpression
import de.wwu.md2.framework.mD2.IntVal
import de.wwu.md2.framework.mD2.SimpleExpression
import de.wwu.md2.framework.mD2.StringVal
import de.wwu.md2.framework.mD2.ViewElementState
import java.util.Date
import java.util.Set

import static de.wwu.md2.framework.generator.util.MD2GeneratorUtil.*

class ConditionClass
{
	private DataContainer dataContainer
	new(DataContainer dataContainer)
	{
		this.dataContainer = dataContainer
	}
	
	def createConditionH(Condition condition, String name) '''
		//
		//  «name.toFirstUpper».h
		//
		//  Generated by MD2 framework on «new Date()».
		//  Copyright (c) 2012 Uni-Muenster. All rights reserved.
		//
		
		#import "«IOSGenerator::md2LibraryImport»/Condition.h"

		@interface «name.toFirstUpper» : Condition
		@end'''
		
	def createConditionM(Condition condition, String name) '''
		//
		//  «name.toFirstUpper».m
		//  TariffCalculator
		//
		//  Created by Uni Münster on «new Date()».
		//  Copyright (c) 2012 Uni-Muenster. All rights reserved.
		//
		
		#import "«name.toFirstUpper».h"
		#import "SpecificAppData.h"
		
		@implementation «name.toFirstUpper»
			
		-(id) init
		{
		    self = [super init];
		    if (self)
		    {
		    	«FOR referencedField : getReferencedFields(condition)»
		    		[identifiers addObject: @"«referencedField»"];
		        «ENDFOR»
		    }
		    return self;
		}
		
		-(BOOL) checkCondition
		{
			return («getConditionString(condition)»);
		}
		
		@end'''
	
	def private Set<String> getReferencedFields(Condition cond)
	{
		val Set<String> result = newHashSet
		for(condExpr : cond.subConditions)
		{
			switch condExpr
			{
				Condition: result.addAll(getReferencedFields(condExpr))
				EqualsExpression:
				{
					val SimpleExpression eqLeft = condExpr.eqLeft
					switch eqLeft { AbstractViewGUIElementRef: result.add(getName(resolveViewGUIElement(eqLeft))) }
					val SimpleExpression eqRight = condExpr.eqRight
					switch eqRight { AbstractViewGUIElementRef: result.add(getName(resolveViewGUIElement(eqRight))) }
				}
				GuiElementStateExpression: result.add(getName(resolveViewGUIElement(condExpr.reference)))
			}
		}
		result.remove(null)
		result
	}
	
	def private String getConditionString(Condition cond)
	{
		val StringBuilder str = new StringBuilder()
		var i = 0
		
		for(condExpr : cond.subConditions)
		{
			// not operator
			if(cond.ops.size > i && cond.ops.get(i).equals("not"))
			{
				str.append("!")
				i = i + 1
			}
			
			// conditional expression
			str.append("(")
			switch condExpr
			{
				Condition:
				{
					str.append(getConditionString(condExpr))
				}
				
				BooleanExpression:
				{
					if(condExpr.value.equals(Boolean::TRUE)) str.append("YES")
					else str.append("NO")
				}
				
				EqualsExpression:
				{
					if(condExpr.not) str.append("!")
					str.append("(").append(getEqualsCondition(condExpr)).append(")")
				}
				
				GuiElementStateExpression:
				{
					if(condExpr.not) str.append("!")
					str.append("(").append(getViewElementStateCondition(condExpr)).append(")")
				}
			}
			str.append(")")
			
			// and / or operator
			if(cond.ops.size > i)
			{
				switch cond.ops.get(i)
				{
					case "and": str.append(" && ")
					case "or": str.append(") || (") // Xcode expects parentheses, even though && has a higher priority than ||, else we get a warning
				}
				i = i + 1
			}
		}
		str.toString
	}
	
	def private getEqualsCondition(EqualsExpression condExpr)
	{
		if(condExpr.eqLeft instanceof IntVal || condExpr.eqRight instanceof IntVal ||
			condExpr.eqLeft instanceof FloatVal || condExpr.eqRight instanceof FloatVal)
		{
			// number condition
			'''«getSimpleExpression(condExpr.eqLeft)» == «getSimpleExpression(condExpr.eqRight)»'''
		}
		else
		{
			// string condition
			'''[«getSimpleExpression(condExpr.eqLeft)» isEqualToString: «getSimpleExpression(condExpr.eqRight)»]'''
		}
	}
	
	def private getSimpleExpression(SimpleExpression expr)
	{
		switch expr
		{
			StringVal: '''@"«expr.value»"'''
			IntVal: '''«expr.value»'''
			FloatVal: '''«expr.value»'''
			AbstractViewGUIElementRef: '''[[SpecificAppData «getName(getViewOfGUIElement(dataContainer.viewContainers, resolveViewGUIElement(expr))).toFirstLower»Controller] getWidgetDataByIdentifier: @"«getName(resolveViewGUIElement(expr))»"]'''
		}
	}
	
	def private getViewElementStateCondition(GuiElementStateExpression expr)
	{
		val state = expr.isState
		switch state
		{
			case ViewElementState::VALID: '''[[SpecificAppData «getName(getViewOfGUIElement(dataContainer.viewContainers, resolveViewGUIElement(expr.reference))).toFirstLower»Controller] checkWidgetValidityByIdentifier: @"«getName(resolveViewGUIElement(expr.reference))»"]'''
			case ViewElementState::EMPTY: '''[[SpecificAppData «getName(getViewOfGUIElement(dataContainer.viewContainers, resolveViewGUIElement(expr.reference))).toFirstLower»Controller] checkWidgetDataByIdentifier: @"«getName(resolveViewGUIElement(expr.reference))»" data: @""]'''
			case ViewElementState::CHECKED: '''[[SpecificAppData «getName(getViewOfGUIElement(dataContainer.viewContainers, resolveViewGUIElement(expr.reference))).toFirstLower»Controller] checkWidgetDataByIdentifier: @"«getName(resolveViewGUIElement(expr.reference))»" data: @"1"]'''
			case ViewElementState::FILLED: '''![[SpecificAppData «getName(getViewOfGUIElement(dataContainer.viewContainers, resolveViewGUIElement(expr.reference))).toFirstLower»Controller] checkWidgetDataByIdentifier: @"«getName(resolveViewGUIElement(expr.reference))»" data: @""]'''
		}
	}
}